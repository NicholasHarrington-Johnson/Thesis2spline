upper <- round(as.numeric(quantile(time(frame$X0),1-prope)),digits=0)
# Keep tsp for pubd
starting <- tsp(frame$pubd)[1]+((lower-1)/365)
ending <- starting+((upper-lower)/365)
# Assign new dimensions
data1 <- frame[lower:upper,1:15]
data2<-matrix(0L,(nrow(data1)-14),15)
for (i in 1:15){
data2[,i] <- data1[(15-i+1):(nrow(data1)-i+1),paste("X",toString(i-1),sep="")]
}
colnames(data2)<-paste("b_t",((1:15)-1),sep="")
data2 <- cbind(data2,frame[(lower+14):upper,c("pubd","pubi","pubny")])
starting <- starting+(14/365)
data2$pubd <- ts(data2$pubd,start=starting,frequency=365)
data2$pubi <- ts(data2$pubi,start=starting,frequency=365)
data2$pubny <- ts(data2$pubny,start=starting,frequency=365)
if (tsp(data2$pubd)[2]!=ending) {print("Error on the dimensions front")
}
tr <- truncatep(r)
frame <- r[[3]]
truncata(frame)
lower <- round(as.numeric(quantile(time(frame$X0),prop)),digits=0)
upper <- round(as.numeric(quantile(time(frame$X0),1-prope)),digits=0)
# Keep tsp for pubd
starting <- tsp(frame$pubd)[1]+((lower-1)/365)
ending <- starting+((upper-lower)/365)
# Assign new dimensions
data1 <- frame[lower:upper,1:15]
data2<-matrix(0L,(nrow(data1)-14),15)
for (i in 1:15){
data2[,i] <- data1[(15-i+1):(nrow(data1)-i+1),paste("X",toString(i-1),sep="")]
}
colnames(data2)<-paste("b_t",((1:15)-1),sep="")
data2 <- cbind(data2,frame[(lower+14):upper,c("pubd","pubi","pubny")])
starting <- starting+(14/365)
data2$pubd <- ts(data2$pubd,start=starting,frequency=365)
data2$pubi <- ts(data2$pubi,start=starting,frequency=365)
data2$pubny <- ts(data2$pubny,start=starting,frequency=365)
tsp(data2$pubd)
rm(list=ls())
source("packages.R")
## Reading data
eztable <- fread("booking_top30_restaurants_all.txt")
## Loading functions
source("function.R")
## Public Holidays
phols <- fread("Public_Holidays_Scaled.csv")
phols <- readph(phols)
## Bookings
restaurants <- c(1:30)[-17]
r <- clean(eztable)
## Truncating data
tr <- truncatep(r)
## Plotting
for(i in restaurants)
{
plotpub(tr[[i]],i)
}
y <- ts(rep(0,1000000),start=2011,end=2015,frequency=365)
for (i in 1:30)
{
x <- r[[i]]$b_t0
x <- x/mean(x)
y <- y + x
}
for (i in 1:30)
{
x <- tr[[i]]$b_t0
x <- x/mean(x)
y <- y + x
}
mean(tr[[2]]$b_t0)
y <- ts(rep(0,1000000),start=2011,end=2015,frequency=365)
for (i in 1:16)
{
x <- tr[[i]]$b_t0
x <- x/mean(x)
y <- y + x
}
y <- y/16
pubd <- r[[1]]$pubd
pubd <- window(pubd,start=tsp(y)[1])
pubd <- window(pubd,end=tsp(y)[2],frequency=365)
pubi <- r[[1]]$pubi
pubi <- window(pubi,start=tsp(y)[1])
pubi <- window(pubi,end=tsp(y)[2],frequency=365)
pubny <- r[[1]]$pubny
pubny <- window(pubny,start=tsp(y)[1])
pubny <- window(pubny,end=tsp(y)[2],frequency=365)
out <- bmod(tr)
print(out)
view(head(tr[[3]]))
head(tr[[3]])
testingph <- readfunction(1)
View(testingph)
rstnum <- 1
# Just look at one restaurant. Could be any of them.
# Pick the second most popular as an example
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
# Convert reservation and booking dates to numerical days
res <- as.timeDate(r2$reservation_datetime)
firstres <- min(res)
res <- as.numeric(res)
book <- as.numeric(as.timeDate(r2$booking_date))
# Remove rows where booking is after reservation
j <- (book <= res)
r2 <- filter(r2, j)
book <- book[j]
res <- res[j]
# Read in public holidays data
phols <- fread("Public_Holidays_Scaled.csv")
# Change public holiday dates to numeric
nphols <- as.numeric(as.timeDate(phols$Date))
# Create time series public holiday variable with appropriate dimensions
# Dimensions hardcoded 2011 to end 2015
pholt <- as.numeric(seq(as.Date("2011-01-01"),as.Date("2015-12-31"),by="1 day"))
ispubh <- ts(pholt %in% nphols, start=2011, frequency=365)
# Public Holidays with suspected decreases
pubd <- nphols[which(phols$Holiday=="1")]
pubd <- ts(as.numeric(pholt %in% pubd), start=2011,frequency = 365)
# Public Holidays with suspected increases
pubi <- nphols[which(phols$Holiday=="2")]
pubi <- ts(as.numeric(pholt %in% pubi), start=2011,frequency = 365)
# New Years Eve - suspected increases
pubny <- nphols[which(phols$Holiday=="3")]
pubny <- ts(as.numeric(pholt %in% pubny),start=2011,frequency = 365)
# Create daily totals. i.e., number of people booked for each day
# Probably much easier ways to do this, but I can't think of them.
# b = number of discrete bookings
# p = number of people booked
res <- as.numeric(res)
book <- as.numeric(book)
book <- book - min(res) + 1
res <- res - min(res) + 1
b <-  matrix(0L, nrow=max(res), ncol=max(res-book+1))
rownames(b) <- paste("Day",1:nrow(b))
colnames(b) <- paste(0:(ncol(b)-1))
p <- b
for(i in 1:nrow(b))
{
tmp <- filter(r2, res==i) # Bookings for day firstres+i-1.
if(nrow(tmp)>0)
{
bk <- i - book[res==i] # days from reservation to booking
daystores <- tabulate(bk+1) # Add one so zeros are counted
b[i,1:length(daystores)] <- daystores
daystores <- tabulate(rep(bk,tmp$people)+1) # Add one so zeros are counted
p[i,1:length(daystores)] <- daystores
}
}
# Remove head rows with zero bookings (prior to restaurant using system)
firstnonzero <- min(which(rowSums(b)>0))
# Remove tail rows with zero bookings
lastnonzero <- max(which(rowSums(b)>0))
# Remove some additional rows before all bookings available
b <- b[firstnonzero:lastnonzero,]
p <- p[firstnonzero:lastnonzero,]
# Compute cumulative reservations
# i.e., reservations
cumB <- t(apply(b,1,function(x){rev(cumsum(rev(x)))}))
cumP <- t(apply(p,1,function(x){rev(cumsum(rev(x)))}))
# Column 1 represents time series of total bookings
# Rows represent cumulating reservations for each day.
# Rearrange matrix so each row contains possible predictors.
# Each row contains bookings available at that date.
B <- cumB
P <- cumP
for(j in 1:(nrow(B)-1))
{
if(j < nrow(B)-1)
{
zb <- diag(cumB[(j+1):nrow(cumB),2:ncol(cumB)])
zp <- diag(cumP[(j+1):nrow(cumP),2:ncol(cumP)])
}
else
{
zb <- cumB[(j+1):nrow(cumB),2:ncol(cumB)]
zp <- cumP[(j+1):nrow(cumP),2:ncol(cumP)]
}
B[j,2:ncol(B)] <- c(zb, rep(NA, ncol(B)-length(zb)-1))
P[j,2:ncol(P)] <- c(zp, rep(NA, ncol(P)-length(zp)-1))
}
# Total people for each day
start <- as.Date(firstres)
yr <- as.numeric(substr(start,1,4))
day <- as.numeric(start - as.Date(paste(as.character(yr),"-01-01",sep="")))
totpeople <- ts(rowSums(p), start=yr+(day/365), frequency=365)
# Total bookings for each day
totbook <- ts(rowSums(b), start=yr+(day/365), frequency=365)
# Compute total future bookings
futurebook <- ts(rowSums(B[,-1],na.rm=TRUE))
futurepeople <- ts(rowSums(P[,-1],na.rm=TRUE))
tsp(futurebook) <- tsp(futurepeople) <- tsp(totbook)
# Truncated due to unusual data patterns at ends
# Further truncation occurs with truncata.R function
startdate <- max(startdate, tsp(totpeople)[1])
enddate <- min(enddate, tsp(totpeople)[2])
totpeople <- window(totpeople,start=startdate,end=enddate)
totbook <- window(totbook,start=startdate,end=enddate)
futurebook <- window(futurebook,start=startdate,end=enddate)
futurepeople <- window(futurepeople,start=startdate,end=enddate)
ispubh <- window(ispubh,start=startdate,end=enddate)
pubd <- window(pubd,start=startdate,end=enddate)
pubi <- window(pubi,start=startdate,end=enddate)
pubny <- window(pubny,start=startdate,end=enddate)
obj <- data.frame(totpeople,totbook,futurebook,futurepeople,
ispubh,pubd,pubi,pubny)
rstnum <- 1
# Just look at one restaurant. Could be any of them.
# Pick the second most popular as an example
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
# Convert reservation and booking dates to numerical days
res <- as.timeDate(r2$reservation_datetime)
firstres <- min(res)
res <- as.timeDate(r2$reservation_datetime)
firstres <- min(res)
View(`r2`)
eztable <- fread("booking_top30_restaurants_all.txt")
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
rm(restaurants)
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
View(eztable)
rstnum <- 1
eztable <- fread("booking_top30_restaurants_all.txt")
# Remove weird numbers.
# Negative people, or more than 10000 people, in a single booking.
# Probably errors
eztable <- filter(eztable, people > 0, people < 1e4)
# Remove cancellations
eztable <- filter(eztable, status!="canceled" & status!='no-show')
# List of restaurants in order of popularity
restaurants <- rev(sort(table(eztable[,restaurant_id])))
# Just look at one restaurant. Could be any of them.
# Pick the second most popular as an example
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
# Convert reservation and booking dates to numerical days
res <- as.timeDate(r2$reservation_datetime)
firstres <- min(res)
res <- as.numeric(res)
book <- as.numeric(as.timeDate(r2$booking_date))
# Remove rows where booking is after reservation
j <- (book <= res)
r2 <- filter(r2, j)
book <- book[j]
res <- res[j]
# Read in public holidays data
phols <- fread("Public_Holidays_Scaled.csv")
# Change public holiday dates to numeric
nphols <- as.numeric(as.timeDate(phols$Date))
# Create time series public holiday variable with appropriate dimensions
# Dimensions hardcoded 2011 to end 2015
pholt <- as.numeric(seq(as.Date("2011-01-01"),as.Date("2015-12-31"),by="1 day"))
ispubh <- ts(pholt %in% nphols, start=2011, frequency=365)
# Public Holidays with suspected decreases
pubd <- nphols[which(phols$Holiday=="1")]
pubd <- ts(as.numeric(pholt %in% pubd), start=2011,frequency = 365)
# Public Holidays with suspected increases
pubi <- nphols[which(phols$Holiday=="2")]
pubi <- ts(as.numeric(pholt %in% pubi), start=2011,frequency = 365)
# New Years Eve - suspected increases
pubny <- nphols[which(phols$Holiday=="3")]
pubny <- ts(as.numeric(pholt %in% pubny),start=2011,frequency = 365)
# Create daily totals. i.e., number of people booked for each day
# Probably much easier ways to do this, but I can't think of them.
res <- as.numeric(res)
book <- as.numeric(book)
book <- book - min(res) + 1
res <- res - min(res) + 1
b <-  matrix(0L, nrow=max(res), ncol=max(res-book+1))
rownames(b) <- paste("Day",1:nrow(b))
colnames(b) <- paste(0:(ncol(b)-1))
p <- b
for(i in 1:nrow(b))
{
tmp <- filter(r2, res==i) # Bookings for day firstres+i-1.
if(nrow(tmp)>0)
{
bk <- i - book[res==i] # days from reservation to booking
daystores <- tabulate(bk+1) # Add one so zeros are counted
b[i,1:length(daystores)] <- daystores
daystores <- tabulate(rep(bk,tmp$people)+1) # Add one so zeros are counted
p[i,1:length(daystores)] <- daystores
}
}
# Remove head rows with zero bookings (prior to restaurant using system)
firstnonzero <- min(which(rowSums(b)>0))
# Remove tail rows with zero bookings
lastnonzero <- max(which(rowSums(b)>0))
# Remove some additional rows before all bookings available
b <- b[firstnonzero:lastnonzero,]
p <- p[firstnonzero:lastnonzero,]
# Compute cumulative reservations
# i.e., reservations
cumB <- t(apply(b,1,function(x){rev(cumsum(rev(x)))}))
cumP <- t(apply(p,1,function(x){rev(cumsum(rev(x)))}))
B <- cumB
P <- cumP
for(j in 1:(nrow(B)-1))
{
if(j < nrow(B)-1)
{
zb <- diag(cumB[(j+1):nrow(cumB),2:ncol(cumB)])
zp <- diag(cumP[(j+1):nrow(cumP),2:ncol(cumP)])
}
else
{
zb <- cumB[(j+1):nrow(cumB),2:ncol(cumB)]
zp <- cumP[(j+1):nrow(cumP),2:ncol(cumP)]
}
B[j,2:ncol(B)] <- c(zb, rep(NA, ncol(B)-length(zb)-1))
P[j,2:ncol(P)] <- c(zp, rep(NA, ncol(P)-length(zp)-1))
}
# Total people for each day
start <- as.Date(firstres)
yr <- as.numeric(substr(start,1,4))
day <- as.numeric(start - as.Date(paste(as.character(yr),"-01-01",sep="")))
totpeople <- ts(rowSums(p), start=yr+(day/365), frequency=365)
# Total bookings for each day
totbook <- ts(rowSums(b), start=yr+(day/365), frequency=365)
# Compute total future bookings
futurebook <- ts(rowSums(B[,-1],na.rm=TRUE))
futurepeople <- ts(rowSums(P[,-1],na.rm=TRUE))
tsp(futurebook) <- tsp(futurepeople) <- tsp(totbook)
# Truncated due to unusual data patterns at ends
# Further truncation occurs with truncata.R function
startdate <- max(startdate, tsp(totpeople)[1])
enddate <- min(enddate, tsp(totpeople)[2])
totpeople <- window(totpeople,start=startdate,end=enddate)
totbook <- window(totbook,start=startdate,end=enddate)
futurebook <- window(futurebook,start=startdate,end=enddate)
futurepeople <- window(futurepeople,start=startdate,end=enddate)
ispubh <- window(ispubh,start=startdate,end=enddate)
pubd <- window(pubd,start=startdate,end=enddate)
pubi <- window(pubi,start=startdate,end=enddate)
pubny <- window(pubny,start=startdate,end=enddate)
obj <- data.frame(totpeople,totbook,futurebook,futurepeople,
ispubh,pubd,pubi,pubny)
start <- as.Date(firstres)
yr <- as.numeric(substr(start,1,4))
day <- as.numeric(start - as.Date(paste(as.character(yr),"-01-01",sep="")))
totpeople <- ts(rowSums(p), start=yr+(day/365), frequency=365)
# Total bookings for each day
totbook <- ts(rowSums(b), start=yr+(day/365), frequency=365)
# Compute total future bookings
futurebook <- ts(rowSums(B[,-1],na.rm=TRUE))
futurepeople <- ts(rowSums(P[,-1],na.rm=TRUE))
tsp(futurebook) <- tsp(futurepeople) <- tsp(totbook)
# Truncated due to unusual data patterns at ends
startdate =0
enddate=9999
startdate <- max(startdate, tsp(totpeople)[1])
enddate <- min(enddate, tsp(totpeople)[2])
totpeople <- window(totpeople,start=startdate,end=enddate)
totbook <- window(totbook,start=startdate,end=enddate)
futurebook <- window(futurebook,start=startdate,end=enddate)
futurepeople <- window(futurepeople,start=startdate,end=enddate)
ispubh <- window(ispubh,start=startdate,end=enddate)
pubd <- window(pubd,start=startdate,end=enddate)
pubi <- window(pubi,start=startdate,end=enddate)
pubny <- window(pubny,start=startdate,end=enddate)
obj <- data.frame(totpeople,totbook,futurebook,futurepeople,
ispubh,pubd,pubi,pubny)
View(obj)
objnew <- data.frame(testingph$x0,testingph$pubd,testingph$pubi,testingph$pubny)
objnew <- data.frame(testingph$X0,testingph$pubd,testingph$pubi,testingph$pubny)
View(objnew)
testingph<-readfunction(24)
source('~/GitHub/Thesis2spline/function.R')
testingph<-readfunction(24)
eztable <- fread("booking_top30_restaurants_all.txt")
phols <- fread("Public_Holidays_Scaled.csv")
phols <- readph(phols)
testingph<-readfunction(24)
objnew <- data.frame(testingph$X0,testingph$pubd,testingph$pubi,testingph$pubny)
rstnum <- 24
eztable <- fread("booking_top30_restaurants_all.txt")
# Remove weird numbers.
# Negative people, or more than 10000 people, in a single booking.
# Probably errors
eztable <- filter(eztable, people > 0, people < 1e4)
# Remove cancellations
eztable <- filter(eztable, status!="canceled" & status!='no-show')
# List of restaurants in order of popularity
restaurants <- rev(sort(table(eztable[,restaurant_id])))
# Just look at one restaurant. Could be any of them.
# Pick the second most popular as an example
r2 <- subset(eztable, restaurant_id==names(restaurants)[rstnum])
# Convert reservation and booking dates to numerical days
res <- as.timeDate(r2$reservation_datetime)
firstres <- min(res)
res <- as.numeric(res)
book <- as.numeric(as.timeDate(r2$booking_date))
# Remove rows where booking is after reservation
j <- (book <= res)
r2 <- filter(r2, j)
book <- book[j]
res <- res[j]
# Read in public holidays data
phols <- fread("Public_Holidays_Scaled.csv")
# Change public holiday dates to numeric
nphols <- as.numeric(as.timeDate(phols$Date))
# Create time series public holiday variable with appropriate dimensions
# Dimensions hardcoded 2011 to end 2015
pholt <- as.numeric(seq(as.Date("2011-01-01"),as.Date("2015-12-31"),by="1 day"))
ispubh <- ts(pholt %in% nphols, start=2011, frequency=365)
# Public Holidays with suspected decreases
pubd <- nphols[which(phols$Holiday=="1")]
pubd <- ts(as.numeric(pholt %in% pubd), start=2011,frequency = 365)
# Public Holidays with suspected increases
pubi <- nphols[which(phols$Holiday=="2")]
pubi <- ts(as.numeric(pholt %in% pubi), start=2011,frequency = 365)
# New Years Eve - suspected increases
pubny <- nphols[which(phols$Holiday=="3")]
pubny <- ts(as.numeric(pholt %in% pubny),start=2011,frequency = 365)
# Create daily totals. i.e., number of people booked for each day
# Probably much easier ways to do this, but I can't think of them.
# b = number of discrete bookings
# p = number of people booked
res <- as.numeric(res)
book <- as.numeric(book)
book <- book - min(res) + 1
res <- res - min(res) + 1
b <-  matrix(0L, nrow=max(res), ncol=max(res-book+1))
rownames(b) <- paste("Day",1:nrow(b))
colnames(b) <- paste(0:(ncol(b)-1))
p <- b
for(i in 1:nrow(b))
{
tmp <- filter(r2, res==i) # Bookings for day firstres+i-1.
if(nrow(tmp)>0)
{
bk <- i - book[res==i] # days from reservation to booking
daystores <- tabulate(bk+1) # Add one so zeros are counted
b[i,1:length(daystores)] <- daystores
daystores <- tabulate(rep(bk,tmp$people)+1) # Add one so zeros are counted
p[i,1:length(daystores)] <- daystores
}
}
# Remove head rows with zero bookings (prior to restaurant using system)
firstnonzero <- min(which(rowSums(b)>0))
# Remove tail rows with zero bookings
lastnonzero <- max(which(rowSums(b)>0))
# Remove some additional rows before all bookings available
b <- b[firstnonzero:lastnonzero,]
p <- p[firstnonzero:lastnonzero,]
# Compute cumulative reservations
# i.e., reservations
cumB <- t(apply(b,1,function(x){rev(cumsum(rev(x)))}))
cumP <- t(apply(p,1,function(x){rev(cumsum(rev(x)))}))
# Column 1 represents time series of total bookings
# Rows represent cumulating reservations for each day.
# Rearrange matrix so each row contains possible predictors.
# Each row contains bookings available at that date.
B <- cumB
P <- cumP
for(j in 1:(nrow(B)-1))
{
if(j < nrow(B)-1)
{
zb <- diag(cumB[(j+1):nrow(cumB),2:ncol(cumB)])
zp <- diag(cumP[(j+1):nrow(cumP),2:ncol(cumP)])
}
else
{
zb <- cumB[(j+1):nrow(cumB),2:ncol(cumB)]
zp <- cumP[(j+1):nrow(cumP),2:ncol(cumP)]
}
B[j,2:ncol(B)] <- c(zb, rep(NA, ncol(B)-length(zb)-1))
P[j,2:ncol(P)] <- c(zp, rep(NA, ncol(P)-length(zp)-1))
}
# Total people for each day
start <- as.Date(firstres)
yr <- as.numeric(substr(start,1,4))
day <- as.numeric(start - as.Date(paste(as.character(yr),"-01-01",sep="")))
totpeople <- ts(rowSums(p), start=yr+(day/365), frequency=365)
# Total bookings for each day
totbook <- ts(rowSums(b), start=yr+(day/365), frequency=365)
# Compute total future bookings
futurebook <- ts(rowSums(B[,-1],na.rm=TRUE))
futurepeople <- ts(rowSums(P[,-1],na.rm=TRUE))
tsp(futurebook) <- tsp(futurepeople) <- tsp(totbook)
# Truncated due to unusual data patterns at ends
# Further truncation occurs with truncata.R function
startdate =0
startdate <- max(startdate, tsp(totpeople)[1])
enddate <- min(enddate, tsp(totpeople)[2])
totpeople <- window(totpeople,start=startdate,end=enddate)
totbook <- window(totbook,start=startdate,end=enddate)
futurebook <- window(futurebook,start=startdate,end=enddate)
futurepeople <- window(futurepeople,start=startdate,end=enddate)
ispubh <- window(ispubh,start=startdate,end=enddate)
pubd <- window(pubd,start=startdate,end=enddate)
pubi <- window(pubi,start=startdate,end=enddate)
pubny <- window(pubny,start=startdate,end=enddate)
obj <- data.frame(totpeople,totbook,futurebook,futurepeople,
ispubh,pubd,pubi,pubny)
View(objnew)
View(obj)
tobjnew<-truncata(objnew)
tobjnew<-truncata(testingph)
View(tobjnew)
source('~/.active-rstudio-document')
source('~/GitHub/Thesis2spline/main.R')
head(tr[[1]])
head(tr[[1]]$paste(b_t,"2",sep=""))
head(tr[[1]][3])
source('~/GitHub/Thesis2spline/function.R')
source('~/GitHub/Thesis2spline/packages.R')
source('~/GitHub/Thesis2spline/packages.R')
source('~/GitHub/Thesis2spline/function.R')
source('~/GitHub/Thesis2spline/function.R')
source('~/GitHub/Thesis2spline/function.R')
